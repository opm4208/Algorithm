1.선형정렬 (선택정렬, 삽입정렬, 버블정렬)

- 선택정렬: 선택정렬은 n개의 데이터가 존재할때 n개의 데이터를 전부 확인하여 가장 작은 값을 첫번째 값과 위치를 바꾸고 다시 두번째 데이터 부터 n개 까지의 데이터를 확인하고 
계속 위치를 바꿔 정렬하는 방식이다 이러한 방식 때문에 시간 복잡도가 최선은 O(n^2) 평균적으로 O(n^2) 최악은 O(n^2)이다.

- 삽입정렬: 삽입정렬은 n개의 데이터가 존재할때 2번째 데이터를 키값으로 하고 키 앞의 값들과 비교하여 키값보다 클시 한칸앞에 그 값들을 저장한다 키의 값보다 작거나 키의 모든 앞의 값을
비교했을 때에는 이동한 만큼 키의 인덱스에서 -하여 키값을 저장한다 이러고 다시 키의 값을 1증가 시켜 계속하다 보면 정렬된다 시간 복잡도는 최선은 O(n) 평균적으로 O(n^2) 최악은 O(n^2)이다.

- 버블정렬: 버블정렬은 n개의 데이터가 존재할때 첫번째 값과 두번째값 두번째와 세번째 이렇게 바로 옆에있는 값들을 비교하여 더 큰 값을 뒤로 놓는 방식이다 이렇게 n번 반복하면 정렬이 된다.
시간 복잡도는 최선은 O(n^2) 평균적으로 O(n^2) 최악은 O(n^2)이다.

2.분할정복정렬 (힙정렬, 병합정렬, 퀵정렬)

- 힙정렬: 힙정렬이란 힙의 특징을 이용해 힙에 데이터들을 저장하여 정렬하는 방식이다 시간 복잡도는 최선은 O(nlogn) 평균적으로 O(nlogn) 최악은 O(nlogn)이다.

- 병합정렬: 병합정렬이란 n개의 데이터가 존재할때 데이터를 절반으로 나눠 저장하고 다시 절반으로 나눠서 데이터가 1개가 될때까지 나눈뒤 나눈 데이터의 옆의 데이터랑 비교하여 작은 수를
앞에 저장하고 데이터를 합친다 이렇게 합쳐진 데이터를 다시 다른 합쳐진 데이터의 앞에부터 비교하여 작은 데이터를 앞에 저장하고 저장한 데이터의 뒤의 데이터를 다시 비교하여 더 작은 수를
계속 저장해 가며 최종적으로 원래의 크기로 정렬된다 시간 복잡도는 최선은 O(nlogn) 평균적으로 O(nlogn) 최악은 O(nlogn)이다.

- 퀵정렬: 퀵정렬이란 n개의 데이터가 존재할때 이중 하나를 pivot으로 지정하여(보통 첫번째 데이터를 지정) 데이터의 피봇을 제외한 맨 앞부분에서 피봇보다 큰 수를 찾을때까지 한칸씩 이동시킨다
큰 수를 찾으면 멈추고 데이터의 맨뒤부터 피봇보다 작은 수를 찾아 점차 내려온다 작은 값을 찾으면 앞에서 찾은 큰수와 작은수의 위치를 바꾼다 그러고 다시 반복한다 만약 앞에서 부터 시작된
인데스와 뒤에서 부터 시작된 인덱스가 만나면 피봇을 앞에서부터 시작된 인덱스와 교환 후 피봇을 기준으로 데이터를 나눠 데이터들을 다시 피봇 작업해준다 이렇게 나누다 더이상 나눌 수 없으면
나눠진 순서대로 데이터를 합치면 정렬이된다 시간 복잡도는 최선은 O(nlogn) 평균적으로 O(nlogn) 최악은 O(n^2)이다.

3. 분할정복정렬 3종의 원리에 의한 특징 조사(힙정렬 특징, 병합정렬 특징, 퀵정렬 특징)

- 힙정렬: 힙정렬은 힙을 사용하여 정렬하기 때문에 데이터의 우선순위가 같을 경우 입력했던 데이터와 출력데이터가 다를수 있다 그리고 포인터 연산이 많아 오버헤드가 발생하고
힙으로 저장을 하기 때문에 메모리 구조상 불러오는데 시간이 좀 더 걸린다(캐시 친화도가 낮다)는 특징이있다.
- 병합정렬: 병합정렬은 데이터를 나눠서 저장하기 때문에 그만큼 메모리를 사용한다는 특징이 있다.
- 퀵정렬: 다른 분할정복정렬과 달리 pivot이 중요하여 최악의 경우 시간복잡도가 O(n^2)이 되는 경우가 있다.
